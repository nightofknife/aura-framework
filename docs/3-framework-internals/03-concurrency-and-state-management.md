# 3. 并发与状态管理

Aura 是一个支持高并发的异步框架，能够同时执行多个任务。为了确保在并发环境下的稳定性和数据一致性，框架内部实现了一套精细的并发控制和状态管理机制。

## 1. 并发模型

Aura 的并发模型主要基于 Python 的 `asyncio` 库，并结合了线程池来实现对阻塞 I/O 操作的异步支持。

*   **`asyncio` 事件循环**: 框架的核心运行在一个 `asyncio` 事件循环上。所有的核心组件，如 `Scheduler` 和 `ExecutionManager`，都是异步的。这使得框架能够高效地处理大量的 I/O 密集型任务，而不会因为等待 I/O 而阻塞整个进程。
*   **线程池**: 对于那些本质上是阻塞的、无法直接进行 `await` 的操作（例如，某些不支持 `asyncio` 的第三方库或者文件操作），Aura 会将其提交到一个独立的线程池 (`ThreadPoolExecutor`) 中执行，从而避免阻塞事件循环。

## 2. 并发控制 (`max_concurrency`)

为了防止系统资源被耗尽，Aura 允许你配置最大并发任务数。

*   **`max_concurrency`**: 这是 `Scheduler` 的一个关键配置项，它定义了在任何一个时间点，最多可以有多少个任务同时处于 `RUNNING` 状态。
*   **工作机制**:
    1.  `Scheduler` 的消费者协程 (`_consume_main_task_queue`) 在从任务队列中取出新任务后，会首先检查当前正在运行的任务数（即 `len(self.running_tasks)`)。
    2.  如果当前运行的任务数小于 `max_concurrency`，它会立即将新任务提交给 `ExecutionManager` 执行。
    3.  如果已经达到并发上限，消费者协程会 `await`，直到有一个正在运行的任务完成并释放出一个并发槽位。

## 3. 核心状态管理

`Scheduler` 是框架的状态管理中心，它维护了几个关键的数据结构来跟踪任务的状态。

*   **`running_tasks` 字典**:
    *   **作用**: 这是最重要的状态跟踪机制。它是一个字典，`key` 是 `task_id`，`value` 是对应的 `Tasklet` 对象。
    *   **生命周期**:
        *   当一个任务从队列中被取出、即将被执行时，它会被添加到 `running_tasks` 中。
        *   当任务执行完成（或失败）后，它会从 `running_tasks` 中被移除。
    *   **用途**: 这个字典不仅用于实现 `max_concurrency` 的限制，还允许框架通过 `task_id` 快速地查询、操作或取消一个正在运行的任务。

*   **`task_queue` (`asyncio.Queue`)**:
    *   **作用**: 这是一个先进先出 (FIFO) 的队列，用于缓冲等待执行的任务。
    *   **线程安全**: `asyncio.Queue` 是为异步环境设计的，本身就是协程安全的。

## 4. 锁机制：确保数据一致性

在并发环境中，对共享数据（如 `running_tasks` 字典）的访问必须受到保护，以防止竞态条件。Aura 使用了两种锁来确保这一点。

*   **`async_data_lock` (`asyncio.Lock`)**:
    *   **类型**: 这是一个 `asyncio` 环境下的锁。
    *   **作用**: 用于保护所有需要在 `async def` 函数中被 `await` 访问的共享数据。
    *   **使用场景**: 当 `Scheduler` 的多个协程可能同时尝试修改 `running_tasks` 时（例如，一个协程在添加任务，另一个协程在任务完成后移除任务），`async_data_lock` 确保了这些操作是原子性的。在修改 `running_tasks` 之前，代码会先 `await self.async_data_lock.acquire()`，在修改完成后 `self.async_data_lock.release()`。

*   **`fallback_lock` (`threading.Lock`)**:
    *   **类型**: 这是一个标准的线程锁。
    *   **作用**: 用于保护那些可能从**非 `async` 环境**（例如，一个单独的线程）访问的共享数据。
    *   **使用场景**: 设想一个场景，框架可能允许一个在线程池中运行的阻塞函数需要回调主线程并修改 `Scheduler` 的状态。在这种跨线程的场景下，就需要使用 `fallback_lock` 来确保线程安全。虽然在核心流程中不常用，但它为框架提供了一层额外的保护，以应对更复杂的插件或集成场景。

通过这些并发控制、状态管理和锁机制的协同工作，Aura 确保了任务调度和执行的高效、稳定和数据一致性。
