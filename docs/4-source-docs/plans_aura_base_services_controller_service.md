# 文件: `plans/aura_base/services/controller_service.py`

## 1. 核心目的

该文件定义了 `ControllerService`，这是一个专门用于**模拟人类输入**的底层服务。它的核心职责是封装 `win32api` 库，为上层应用提供一个统一、高级且跨平台的接口，用于执行**鼠标移动、点击、拖拽、滚轮滚动**以及**键盘按键、输入文本**等所有与硬件输入设备相关的操作。

此服务的设计目标是屏蔽底层操作系统 API 的复杂性和差异性，并提供带有**平滑动画**和**非阻塞延迟**的高级功能。

## 2. 关键组件与功能

*   **`KEY_MAP`**: 一个全局字典，用于将人类可读的按键名称（如 `'enter'`, `'f1'`, `'ctrl'`）映射到 Windows 虚拟键码（Virtual-Key Codes），这是调用 `win32api` 所必需的。

*   **`ControllerService`**:
    *   **`__init__()`**: 初始化服务。它创建了 `_held_keys` 和 `_held_mouse_buttons` 两个集合，用于追踪当前被程序按下的键和鼠标按钮的状态，以便在程序退出或需要时能够全部释放。
    *   **`release_all_async()`**: 一个重要的安全功能，用于异步地释放所有当前被程序按下的按键和鼠标按钮，防止因程序异常中断而导致某个按键或鼠标一直处于“按下”状态。
    *   **`move_to_async(x, y, duration)`**: 实现了**平滑的、带动画的鼠标移动**。它不是瞬时地将鼠标光标设置到目标位置，而是在指定的 `duration` 时间内，通过一个循环计算出一系列中间点，并逐步移动鼠标，从而模拟出人类的移动轨迹。
    *   **`click_async(...)`**: 封装了完整的点击操作，包括可选的移动、按下、短暂延迟、松开。支持多次点击和自定义间隔。
    *   **`drag_to_async(...)`**: 封装了完整的拖拽操作：按下鼠标 -> 平滑移动到目标位置 -> 松开鼠标。
    *   **`type_text_async(text, ...)`**: 实现了模拟真人输入文本的功能。它会遍历输入字符串中的每一个字符，并能智能地判断是否需要同时按下 `Shift` 键来输入大写字母或符号。
    *   **原子操作 (如 `mouse_down`, `key_down`)**: 这些是底层的、**瞬时**的同步方法。它们直接调用 `win32api` 来执行按下或松开的操作。由于这些操作本身几乎不耗时，为了减少不必要的异步开销，它们被设计为同步的。
    *   **`hold_key_async`**: 一个**异步上下文管理器**，极大地简化了需要“按住某个键执行一系列异步操作，然后松开”的场景。
    *   **同步接口与桥接器**: 与其他服务一样，它为所有包含延迟或动画的异步方法（如 `move_to_async`）都提供了同步的封装接口（`move_to`），并通过 `_submit_to_loop_and_wait` 桥接器来调用，确保对外接口的统一和易用。

## 3. 核心逻辑解析

`ControllerService` 的核心逻辑在于其如何将**离散的、瞬时的底层输入事件**组合成**连续的、带时间维度的用户行为**，并通过 `asyncio` 实现非阻塞的延迟。

以 `move_to_async` 方法为例，其平滑移动的实现是该服务的一个标志性功能：

1.  **获取起点**: `start_x, start_y = await asyncio.to_thread(win32api.GetCursorPos)`。它首先通过 `asyncio.to_thread` 在后台线程获取当前鼠标的屏幕位置，避免了对 `win32api` 的直接阻塞调用。

2.  **计算步数**: `steps = max(int(duration / 0.01), 1)`。它根据用户期望的移动时长 `duration` 和一个固定的时间片（这里是 `0.01` 秒，约等于 100 FPS 的刷新率）来计算出总共需要移动多少步。这确保了无论 `duration` 多长，移动动画都能保持相对流畅。

3.  **插值循环**: `for i in range(1, steps + 1): ...`。这是动画的核心。在每一次循环中：
    *   **线性插值**: `progress = i / steps` 计算出当前动画的完成度（从 0.0 到 1.0）。然后通过 `inter_x = int(start_x + (x - start_x) * progress)` 计算出当前这一帧鼠标应该在的**中间点坐标**。这是一种简单的线性插值算法。
    *   **设置位置**: `await asyncio.to_thread(win32api.SetCursorPos, ...)`。将计算出的中间点坐标通过后台线程设置给鼠标。
    *   **非阻塞延迟**: `await asyncio.sleep(duration / steps)`。这是与 `time.sleep()` 的关键区别。它会**非阻塞**地暂停当前协程一小段时间，将CPU控制权交还给事件循环，让其他任务可以并发执行。

通过这个循环，`move_to_async` 将一次完整的鼠标移动分解成了数十个“移动一小步 -> 暂停一小会”的微操作序列。由于 `asyncio.sleep` 的非阻塞特性，在鼠标移动的整个过程中，Aura 框架的事件循环始终保持活跃，可以同时处理截图、网络请求或其他任何异步任务，从而实现了高性能的并发模拟输入。