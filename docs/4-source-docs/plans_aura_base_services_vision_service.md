# 文件: `plans/aura_base/services/vision_service.py`

## 1. 核心目的

该文件定义了 `VisionService`，一个专门用于处理**计算机视觉**任务的服务。它的核心职责是封装 `OpenCV` 库，为上层应用提供**无状态**的、原子化的图像处理功能，主要包括**模板匹配**和**颜色查找**。

该服务被设计为一个纯粹的计算引擎，接收图像数据作为输入，并返回结构化的分析结果。与 `ScreenService` 不同，它不关心图像的来源（是来自屏幕截图还是文件），只负责处理计算任务。

## 2. 关键组件与功能

*   **`VisionService`**:
    *   **`__init__()`**: 初始化服务。由于该服务是无状态的，其构造函数非常简单，仅初始化了用于同步/异步桥接的锁和事件循环变量。
    *   **`find_template_async(...)`**: 在源图像中查找与模板图像最匹配的单个区域。这是服务最核心的功能之一。它将 CPU 密集的 `cv2.matchTemplate` 和 `cv2.minMaxLoc` 函数调用通过 `asyncio.to_thread` 调度到后台线程执行，以避免阻塞主事件循环。
    *   **`find_all_templates_async(...)`**: 在源图像中查找**所有**满足置信度阈值的匹配区域。它不仅使用了模板匹配，还额外调用了 `cv2.dnn.NMSBoxes`（非极大值抑制）来合并重叠的检测框，从而得到更精确、无冗余的匹配结果。整个计算密集的过程同样被封装在一个函数内并调度到后台线程。
    *   **`find_color_async(...)`**: 在源图像中查找指定 HSV 颜色范围内的最大连通区域。它使用 `cv2.inRange` 创建颜色掩码，并通过 `cv2.findContours` 找到所有轮廓，最后找出面积最大的一个。这个过程也是在后台线程中完成的。
    *   **`_prepare_image(...)`**: 一个关键的内部辅助函数。它负责将输入的图像（可能是文件路径 `str`，或 `numpy` 数组）统一处理成标准的、单通道的灰度图 (`np.ndarray`)。这确保了后续的 `OpenCV` 函数能接收到格式正确的输入。它还处理了不同的图像通道情况（如 BGRA, BGR），增加了接口的健壮性。
    *   **同步接口 (如 `find_template`)**: 与项目中的其他服务一样，它为每个核心的异步方法提供了一个同名的**同步封装**，通过 `_submit_to_loop_and_wait` 桥接器来调用异步内核，保持了对外接口的一致性和易用性。

*   **`MatchResult` / `MultiMatchResult`**: 用于封装视觉查找结果的 `dataclass`。它们提供了标准化的输出格式，包含了是否找到、位置、中心点、置信度等丰富信息，使得上层调用者可以方便地处理和使用这些结果。

## 3. 核心逻辑解析

`VisionService` 的核心逻辑在于它如何将**CPU 密集型**的计算机视觉算法无缝集成到异步框架中。其关键在于对 `asyncio.to_thread` 的有效利用。

以 `find_all_templates_async` 方法为例，其执行流程深刻体现了这一设计思想：

1.  **预处理**: 在主线程（事件循环线程）中，它首先调用 `_prepare_image` 对输入的源图像和模板图像进行预处理。这些操作（如图像加载、灰度转换）通常很快，因此在主线程中执行是安全的，可以避免线程切换的开销。

2.  **封装阻塞操作**: 所有耗时的 `OpenCV` 计算都被封装在一个名为 `_find_and_filter` 的**内部同步函数**中。这个函数包含了：
    *   `cv2.matchTemplate`: 执行模板匹配，生成一个表示匹配程度的“热力图”。
    *   `np.where`: 从热力图中筛选出所有置信度高于阈值的位置点。
    *   `cv2.dnn.NMSBoxes`: 对筛选出的矩形框进行非极大值抑制，消除冗余的重叠框。
    *   构建 `MatchResult` 对象列表。

3.  **调度到线程池**: `find_all_templates_async` 方法的核心调用是 `await asyncio.to_thread(_find_and_filter)`。
    *   `asyncio.to_thread` 会从内部管理的 `ThreadPoolExecutor` 中取出一个空闲线程。
    *   它将 `_find_and_filter` 函数提交给这个线程去执行。
    *   当前协程会 `await`，即暂停执行并让出控制权，直到后台线程完成计算并返回结果。

4.  **返回结果**: 后台线程完成计算后，`await` 结束，`find_all_templates_async` 接收到 `_find_and_filter` 的返回值（即 `MatchResult` 列表），并将其包装在 `MultiMatchResult` 中返回给调用者。

通过这种方式，耗时长达数百毫秒甚至数秒的 `OpenCV` 计算被完全隔离在后台线程中，**主事件循环**始终保持空闲，可以继续响应其他请求。这使得 Aura 框架即使在执行复杂的视觉分析任务时，其核心调度和 API 服务也能保持极高的响应性，这是构建高性能自动化系统的关键。