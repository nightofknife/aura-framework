# 文件: `main.py`

## 1. 核心目的

该文件是 Aura 框架的**交互式命令行界面 (CLI)** 的主入口点。它的核心目的是为用户提供一个简单、直接的方式来与 Aura 框架进行交互，而无需直接编写代码或调用 API。用户可以通过一个文本菜单来启动和停止核心调度器、查看已加载的资源，以及将任务手动添加到执行队列中。

## 2. 关键组件与功能

*   **`get_scheduler()`**: 这是一个工厂函数，负责以**单例模式**创建和返回全局唯一的 `Scheduler` 实例。首次调用时，它会执行必要的初始化，包括设置日志系统和加载所有插件与任务定义。后续调用则直接返回已创建的实例。

*   **`main()`**: 程序的主循环。它负责初始化调度器实例，然后进入一个无限循环，在循环中不断地显示主菜单 (`display_menu()`)、接收用户输入，并根据用户的选择调用对应的功能函数。

*   **`display_menu()`**: 根据调度器的当前运行状态（`scheduler_is_running`），动态地生成并显示主菜单。例如，如果调度器正在运行，菜单会显示“停止调度器”选项，反之则显示“启动调度器”。

*   **`manage_scheduler_lifecycle()`**: 该函数封装了启动和停止调度器的逻辑。
    *   **启动**: 调用 `scheduler.start_scheduler()` 后，它并不会立即返回，而是会通过 `scheduler.startup_complete_event.wait()` 等待一个同步事件。这个事件由 `Scheduler` 的后台线程在所有核心服务（如消费者协程）完全初始化后设置。这种**事件同步机制**比简单的 `time.sleep()` 更加健壮和可靠，确保了在宣告“启动成功”时，框架确实已经准备就绪。
    *   **停止**: 调用 `scheduler.stop_scheduler()` 来优雅地关闭所有后台服务。

*   **`run_task(ad_hoc_mode: bool)`**: 处理将任务添加到队列的交互逻辑。
    *   `ad_hoc_mode=False`: 显示 `schedule.yaml` 中定义的可调度任务列表。
    *   `ad_hoc_mode=True`: 显示所有已加载 Plans 中的**全部**任务定义，允许用户临时运行任何任务。
    *   它会接收用户选择的任务编号和希望运行的次数，然后循环调用 `scheduler.run_manual_task()` 或 `scheduler.run_ad_hoc_task()` 将任务批量添加到队列。

*   **`list_all_plans()` / `list_all_actions()`**: 用于查询并向用户展示当前 Aura 实例中所有已加载的 Plans 和 Actions 的信息，提供了良好的系统透明度。

## 3. 核心逻辑解析

`main.py` 的核心逻辑在于它如何作为一个**同步的命令行应用**与 Aura 框架**高度异步的内核**进行交互。这种交互模式的关键在于 `Scheduler` 类的设计。

`Scheduler` 的 `start_scheduler()` 和 `stop_scheduler()` 方法是**线程安全**的。当 `manage_scheduler_lifecycle` 在主线程中调用 `scheduler.start_scheduler()` 时，`Scheduler` 会在内部创建一个新的后台线程来运行其 `asyncio` 事件循环。这意味着 `start_scheduler()` 调用会立即返回，而不会阻塞主线程的 CLI 菜单循环。

这种设计带来了几个好处：
1.  **UI 不被阻塞**: 用户启动调度器后，CLI 的菜单依然可以响应用户的其他输入（例如，继续添加新任务或请求停止），因为主线程没有被异步的事件循环所阻塞。
2.  **实时日志**: 由于调度器在后台运行，它产生的日志可以通过配置好的日志系统实时地显示在用户的控制台上，用户可以在 CLI 界面上看到任务执行的实时进展，而无需切换窗口或查看日志文件。
3.  **优雅的启动与关闭**: 通过使用 `threading.Event` (`startup_complete_event`)，主线程的 CLI 可以精确地知道后台的 `Scheduler` 何时真正准备好接受任务，避免了在服务未完全就绪时就进行操作的竞态条件。同样，`stop_scheduler()` 方法会确保在程序退出前，所有后台任务都被优雅地清理。

总而言之，`main.py` 不仅仅是一个简单的脚本，它是一个精心设计的客户端，通过线程和同步事件，巧妙地解决了同步世界（命令行）与异步世界（Aura核心）之间的通信与协调问题。